1
00:00:00,130 --> 00:00:03,230
 Personas are meant to give us a small number of characters that we can reason

2
00:00:03,230 --> 00:00:04,950
 about empatheticly.

3
00:00:04,950 --> 00:00:08,730
 However, it can sometimes also be useful to formulaicly generate

4
00:00:08,730 --> 00:00:13,890
 a large number of user profiles to explore the full design space.

5
00:00:13,890 --> 00:00:18,177
 We can do this by defining a number of different variable about our users and

6
00:00:18,177 --> 00:00:20,093
 the possibilities within each.

7
00:00:20,093 --> 00:00:23,455
 So here our few examples, we can ask ourselves,

8
00:00:23,455 --> 00:00:27,950
 do we care about novice users or expert users or both?

9
00:00:27,950 --> 00:00:30,710
 Do we care about users that read casually, that read seriously, or

10
00:00:30,710 --> 00:00:32,270
 both kinds of users?

11
00:00:32,270 --> 00:00:35,234
 Do we only want to cater to users that are highly motivated to use our app,

12
00:00:35,234 --> 00:00:37,189
 which can make things a little bit easier on us?

13
00:00:37,189 --> 00:00:39,837
 Or do we want to assume that it won't take much to stop them

14
00:00:39,837 --> 00:00:41,575
 from using our app?

15
00:00:41,575 --> 00:00:44,555
 Can we assume a pretty high-level of technological literacy, or

16
00:00:44,555 --> 00:00:47,755
 are we trying to cater to more casual users as well?

17
00:00:47,755 --> 00:00:51,203
 And are we interested in users that are going to use our app all the time, or

18
00:00:51,203 --> 00:00:54,277
 in users who are going to use our app only occasionally, or both?

19
00:00:54,277 --> 00:00:58,462
 All of these decisions present some interesting design considerations that

20
00:00:58,462 --> 00:00:59,757
 we need to keep in mind.

21
00:00:59,757 --> 00:01:03,222
 For example, for users that are going to use our tool very often,

22
00:01:03,222 --> 00:01:05,432
 our major consideration is efficiency.

23
00:01:05,432 --> 00:01:08,618
 We want to make sure they can do what they need to do as quickly as possible.

24
00:01:08,618 --> 00:01:09,608
 And oftentimes,

25
00:01:09,608 --> 00:01:13,530
 that might be relying on them to know more about how to use the app.

26
00:01:13,530 --> 00:01:16,225
 But if we're designing for users that use our app pretty rarely,

27
00:01:16,225 --> 00:01:19,365
 we need to make sure to keep all the interactions discoverable and visible.

28
00:01:19,365 --> 00:01:21,330
 That way every time they come back to the app,

29
00:01:21,330 --> 00:01:23,360
 it's like the first time they came back to it.

30
00:01:23,360 --> 00:01:26,250
 They don't need to remember anything from the previous time because

31
00:01:26,250 --> 00:01:29,150
 we don't know how long it's been since the last time they've used it.

32
00:01:29,150 --> 00:01:32,610
 If we want to design for both, then we have our work cut out for us.

33
00:01:32,610 --> 00:01:35,910
 We need to either design very efficient interaction methods that nonetheless

34
00:01:35,910 --> 00:01:36,880
 are discoverable and

35
00:01:36,880 --> 00:01:41,340
 visible, or we need to design two sets of interaction methods.

36
00:01:41,340 --> 00:01:43,780
 One way that's very discoverable and visible, and

37
00:01:43,780 --> 00:01:45,490
 one way that's very efficient.

38
00:01:45,490 --> 00:01:49,010
 We see this with our example of the hotkeys for copy and paste.

39
00:01:49,010 --> 00:01:51,939
 If you don't know how to use them, you have a way of finding them.

40
00:01:51,939 --> 00:01:53,768
 So it caters to either novice users or

41
00:01:53,768 --> 00:01:56,160
 users who haven't used the program in awhile.

42
00:01:56,160 --> 00:01:58,580
 But because you can also do it with simple hotkeys,

43
00:01:58,580 --> 00:02:00,860
 it caters to those users who use it more frequently and

44
00:02:00,860 --> 00:02:04,040
 makes it more efficient for those who are going to be doing it a lot.

45
00:02:04,040 --> 00:02:07,220
 In deciding what to design, we need to understand what groups,

46
00:02:07,220 --> 00:02:12,240
 what profiles we're designing for, and use that to inform our design decisions.

47
00:02:12,240 --> 00:02:14,910
 Inexperienced designers often make big mistakes here.

48
00:02:14,910 --> 00:02:18,720
 They either try to design for everybody, which rarely works, or

49
00:02:18,720 --> 00:02:21,080
 they design with no one in particular in mind.

50
00:02:21,080 --> 00:02:24,920
 And so, certain areas of program are good for some users, others are good for

51
00:02:24,920 --> 00:02:26,160
 other types of users.

52
00:02:26,160 --> 00:02:30,067
 An entire program as a whole is not good for any particular type of user.

53
00:02:30,067 --> 00:02:33,530
 So it's very important that we understand the range of users that we're

54
00:02:33,530 --> 00:02:37,163
 designing for, and that we make sure the range is actually something that we

55
00:02:37,163 --> 00:02:37,163
 feasibly can design for.


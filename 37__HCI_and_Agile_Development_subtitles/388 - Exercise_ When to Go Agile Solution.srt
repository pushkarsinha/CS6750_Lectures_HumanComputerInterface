1
00:00:00,000 --> 00:00:01,515
 Here would be my answers.

2
00:00:01,515 --> 00:00:03,690
 The two areas that I think are good candidates,

3
00:00:03,690 --> 00:00:06,180
 for an agile development process are the two that use

4
00:00:06,180 --> 00:00:09,615
 existing devices and don't have high stakes associated with them.

5
00:00:09,615 --> 00:00:12,930
 In both these cases, rolling out updates wouldn't be terribly difficult,

6
00:00:12,930 --> 00:00:16,650
 and we haven't lost a whole lot by initially having a product that has some bugs in it.

7
00:00:16,650 --> 00:00:19,140
 A camera interface for any MOOC recording would be

8
00:00:19,140 --> 00:00:22,435
 a good candidate if the camera environment was easier to program for.

9
00:00:22,435 --> 00:00:24,915
 The programming for a camera isn't like programming for

10
00:00:24,915 --> 00:00:27,360
 an App Store or for a desktop environment.

11
00:00:27,360 --> 00:00:28,920
 I actually don't even know how you go about it.

12
00:00:28,920 --> 00:00:31,830
 So, for us, a camera interface for aiding MOOC recording

13
00:00:31,830 --> 00:00:35,745
 probably wouldn't be a great candidate because we don't have access to that platform.

14
00:00:35,745 --> 00:00:40,160
 Remember, our goal is to get products in front of real users as soon as possible.

15
00:00:40,160 --> 00:00:42,830
 Now, of course, that all changes if we're actually working for a camera company,

16
00:00:42,830 --> 00:00:44,650
 and we do have access to that platform.

17
00:00:44,650 --> 00:00:46,670
 The second one is more fundamental though,

18
00:00:46,670 --> 00:00:50,015
 a tool for helping doctors visualize patient information in surgery.

19
00:00:50,015 --> 00:00:52,010
 There are really high-stakes behind that.

20
00:00:52,010 --> 00:00:55,160
 If you visualize something in a way that's a little bit misleading, someone could die.

21
00:00:55,160 --> 00:00:58,130
 So, you probably don't want to take an agile development process for that.

22
00:00:58,130 --> 00:01:00,590
 For a wearable device for mobile keyboard entry,

23
00:01:00,590 --> 00:01:03,085
 wearable devices are expensive to produce.

24
00:01:03,085 --> 00:01:05,120
 When you are actually producing the physical device,

25
00:01:05,120 --> 00:01:07,295
 you want to be sure it's going to work pretty well.

26
00:01:07,295 --> 00:01:10,860
 Similarly, devices are easy to update the way software is.

27
00:01:10,860 --> 00:01:15,020
 So, wearable devices is probably not a good candidate for an agile development process.

28
00:01:15,020 --> 00:01:18,140
 Finally, a navigation app for the console of an electric car,

29
00:01:18,140 --> 00:01:19,540
 I said isn't a good candidate,

30
00:01:19,540 --> 00:01:20,630
 although you might disagree.

31
00:01:20,630 --> 00:01:23,830
 Personally, I would say that the stakes are high enough for navigation app,

32
00:01:23,830 --> 00:01:25,910
 that you probably want to be pretty sure that you're going to

33
00:01:25,910 --> 00:01:28,375
 have a good product before you roll it out to users.

34
00:01:28,375 --> 00:01:30,950
 It might take a wrong turn or end up in the wrong neighborhood or

35
00:01:30,950 --> 00:01:33,380
 missing appointment based on some mistakes that we make.

36
00:01:33,380 --> 00:01:37,355
 I would consider that sufficiently high stakes to avoid a faster development process.

37
00:01:37,355 --> 00:01:39,965
 Plus, not all electric cars are like Tesla.

38
00:01:39,965 --> 00:01:42,290
 Some of them actually have to have you bring the car

39
00:01:42,290 --> 00:01:44,600
 to the factory or to the repair shop to get an update.

40
00:01:44,600 --> 00:01:44,600
 So, the cost of rolling out updates can be more significant there as well.


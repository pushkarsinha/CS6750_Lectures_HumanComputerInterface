1
00:00:00,000 --> 00:00:03,825
 There are strengths and weaknesses to the GOMS representation for tasks.

2
00:00:03,825 --> 00:00:05,850
 One weakness is that it doesn't automatically

3
00:00:05,850 --> 00:00:08,460
 address a lot of the complexity of these problems.

4
00:00:08,460 --> 00:00:10,860
 For example, there are likely many different methods

5
00:00:10,860 --> 00:00:12,885
 and submethods for addressing this goal.

6
00:00:12,885 --> 00:00:15,900
 Before even getting this selection rules among what route to take,

7
00:00:15,900 --> 00:00:17,010
 you might decide whether to take

8
00:00:17,010 --> 00:00:19,520
 public transportation or whether to work from home that day.

9
00:00:19,520 --> 00:00:20,915
 In parallel to that,

10
00:00:20,915 --> 00:00:22,700
 even after deciding to drive,

11
00:00:22,700 --> 00:00:25,825
 you might decide what car to take if your family has more than one car.

12
00:00:25,825 --> 00:00:28,495
 The standard GOMS model leaves those kind of things out,

13
00:00:28,495 --> 00:00:30,440
 although there are augmented versions that have been

14
00:00:30,440 --> 00:00:32,390
 created to deal with this kind of complexity

15
00:00:32,390 --> 00:00:36,785
 like CMN GOMS or in GOMS L. We'll talk about those a bit more later.

16
00:00:36,785 --> 00:00:39,500
 A second weakness is that the GOMS model assumes

17
00:00:39,500 --> 00:00:42,140
 the user already has these methods in mind,

18
00:00:42,140 --> 00:00:44,735
 that means the user is already an expert in the area.

19
00:00:44,735 --> 00:00:49,450
 GOMS models don't do a good job of accounting for novices or accounting for user errors.

20
00:00:49,450 --> 00:00:52,400
 For example, if you are driving in an unfamiliar location,

21
00:00:52,400 --> 00:00:54,030
 you don't even know what the methods are,

22
00:00:54,030 --> 00:00:55,910
 let alone how to choose among them.

23
00:00:55,910 --> 00:00:59,330
 The strength of GOMS models on the other hand is their ability to

24
00:00:59,330 --> 00:01:03,940
 formalize user interaction into steps that we can use to actually make predictions.

25
00:01:03,940 --> 00:01:07,310
 We can measure how long each these operators takes and so we

26
00:01:07,310 --> 00:01:10,870
 can predict the overall efficiency of using a certain interface.

27
00:01:10,870 --> 00:01:13,430
 For example, in this GOMS model if we had included

28
00:01:13,430 --> 00:01:16,340
 the operator to pull keys out of the users pocket,

29
00:01:16,340 --> 00:01:19,250
 we might quickly identify that the relative efficiency of

30
00:01:19,250 --> 00:01:23,405
 these two methods is very much dependent on how long that step takes.

31
00:01:23,405 --> 00:01:25,595
 The Key Chain method might be a lot faster

32
00:01:25,595 --> 00:01:28,040
 if the user can get their key chain out pretty quickly.

33
00:01:28,040 --> 00:01:29,240
 But for other users,

34
00:01:29,240 --> 00:01:30,740
 the fact that they need to pull something out of

35
00:01:30,740 --> 00:01:33,110
 their pocket while holding bags or holding a baby,

36
00:01:33,110 --> 00:01:35,440
 makes a keypad a more efficient option.

37
00:01:35,440 --> 00:01:37,255
 By performing that kind of reasoning,

38
00:01:37,255 --> 00:01:37,255
 we can focus on areas that either method and the interface as a whole can be improved.


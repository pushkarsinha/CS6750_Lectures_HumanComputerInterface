1
00:00:00,000 --> 00:00:03,360
 We can't constrain away all errors all the time though.

2
00:00:03,360 --> 00:00:05,910
 So, there are two principles for how we deal with

3
00:00:05,910 --> 00:00:09,255
 errors that do occur, feedback and tolerance.

4
00:00:09,255 --> 00:00:14,010
 Tolerance means that users shouldn't be at risk of causing too much trouble accidentally.

5
00:00:14,010 --> 00:00:15,760
 For this Nielsen writes that,

6
00:00:15,760 --> 00:00:18,210
 "Users often choose system functions by mistake,

7
00:00:18,210 --> 00:00:20,910
 and will need a clearly marked 'emergency exit' to

8
00:00:20,910 --> 00:00:24,165
 leave the unwanted state without having to go through an extended dialogue.

9
00:00:24,165 --> 00:00:26,475
 Support, undo and redo."

10
00:00:26,475 --> 00:00:27,885
 For Constantine and Lockwood,

11
00:00:27,885 --> 00:00:29,505
 this is the tolerance principle.

12
00:00:29,505 --> 00:00:31,980
 They write, "The design should be flexible and tolerant,

13
00:00:31,980 --> 00:00:36,480
 reducing the cost of mistakes and misuse by allowing undoing and redoing,

14
00:00:36,480 --> 00:00:38,735
 while also preventing errors wherever possible."

15
00:00:38,735 --> 00:00:40,160
 It should be becoming clear why

16
00:00:40,160 --> 00:00:43,325
 that Control-Y issue with Visual Studio was so significant.

17
00:00:43,325 --> 00:00:46,685
 Undo and redo are fundamental concepts of tolerance,

18
00:00:46,685 --> 00:00:49,640
 and that Control-Y issue where Control-Y removes the line in

19
00:00:49,640 --> 00:00:54,550
 Visual Studio gets in the way of redo allowing us to recover from mistakes.

20
00:00:54,550 --> 00:00:58,065
 For Dix et al., this is the principle of recoverability.

21
00:00:58,065 --> 00:01:02,510
 Now, Nielsen's definition is most interested in supporting user experimentation.

22
00:01:02,510 --> 00:01:05,605
 The system should tolerate users poking around with things.

23
00:01:05,605 --> 00:01:07,200
 Universal design simply says,

24
00:01:07,200 --> 00:01:08,870
 "The design minimizes hazards and

25
00:01:08,870 --> 00:01:12,490
 the adverse consequences of accidental or unintended actions."

26
00:01:12,490 --> 00:01:16,195
 Dix et al. also refers to this as the principle of recoverability.

27
00:01:16,195 --> 00:01:20,720
 Now, Nielsen's definition is most interested in supporting user experimentation.

28
00:01:20,720 --> 00:01:23,720
 The system should tolerate users poking around with things.

29
00:01:23,720 --> 00:01:26,885
 That actually enhances the principle of discoverability.

30
00:01:26,885 --> 00:01:29,720
 Because if the user feels safe experimenting with things,

31
00:01:29,720 --> 00:01:32,090
 they're more likely to discover what's available to them.

32
00:01:32,090 --> 00:01:34,190
 The principles from Constantine and Lockwood,

33
00:01:34,190 --> 00:01:36,590
 and the principles of universal design are more

34
00:01:36,590 --> 00:01:39,215
 about recovering from traditional mistakes.

35
00:01:39,215 --> 00:01:43,020
 Jef Raskin poses this as a more humorous law of interface design,

36
00:01:43,020 --> 00:01:46,325
 "A computer shall not harm your work or through inactivity,

37
00:01:46,325 --> 00:01:48,370
 allow your work to come to harm."

38
00:01:48,370 --> 00:01:50,360
 So, we first have to make sure that the system

39
00:01:50,360 --> 00:01:53,164
 prevents the user from doing too much damage accidentally.

40
00:01:53,164 --> 00:01:56,270
 Either by constraining them away from making those mistakes,

41
00:01:56,270 --> 00:01:56,270
 or allowing an easy way to recover once those mistakes have been made.


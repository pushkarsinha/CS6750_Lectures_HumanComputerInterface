1
00:00:00,000 --> 00:00:01,814
 In designing user interfaces,

2
00:00:01,814 --> 00:00:04,815
 our goal is typically to make the interface usable,

3
00:00:04,815 --> 00:00:08,265
 and a big part of usability is accounting for user error.

4
00:00:08,265 --> 00:00:11,910
 Many design theorists argue that there's actually no such thing as user error.

5
00:00:11,910 --> 00:00:13,500
 If the user commits an error,

6
00:00:13,500 --> 00:00:17,475
 it was because the system was not structured in a way to prevent or recover from it,

7
00:00:17,475 --> 00:00:19,485
 and I happen to agree with that.

8
00:00:19,485 --> 00:00:21,870
 Now, one way we can avoid error is by

9
00:00:21,870 --> 00:00:25,005
 preventing the user from performing erroneously in the first place.

10
00:00:25,005 --> 00:00:27,285
 This is the idea of constraints.

11
00:00:27,285 --> 00:00:31,470
 Constraining the user to only perform the correct actions in the first place.

12
00:00:31,470 --> 00:00:34,020
 On constraints, Norman writes that constraints are

13
00:00:34,020 --> 00:00:37,530
 powerful clues limiting the set of possible actions.

14
00:00:37,530 --> 00:00:40,140
 The thoughtful use of constraints in design lets people

15
00:00:40,140 --> 00:00:42,690
 readily determine the proper course of action,

16
00:00:42,690 --> 00:00:45,075
 even in a novel situation.

17
00:00:45,075 --> 00:00:48,410
 Remember, designing so that users are immediately comfortable in

18
00:00:48,410 --> 00:00:52,270
 novel situations is one of the goals of good user interface design.

19
00:00:52,270 --> 00:00:56,000
 Nielsen notes that even better than good error messages is

20
00:00:56,000 --> 00:00:59,630
 a careful design which prevents a problem from occurring in the first place.

21
00:00:59,630 --> 00:01:02,900
 Either eliminate error-prone conditions or check for them and

22
00:01:02,900 --> 00:01:06,355
 present users with a confirmation option before they commit to the action.

23
00:01:06,355 --> 00:01:08,750
 For example, if our application was prone to

24
00:01:08,750 --> 00:01:11,689
 users accidentally closing it when they don't mean to,

25
00:01:11,689 --> 00:01:14,815
 ask them when it's about to close if that's actually what they meant to do.

26
00:01:14,815 --> 00:01:17,410
 Both of these approaches refer to the need to

27
00:01:17,410 --> 00:01:20,610
 stop faulty user input before it's even received.

28
00:01:20,610 --> 00:01:23,530
 This is a principle you might already encountered a lot.

29
00:01:23,530 --> 00:01:26,125
 Our password reset screen actually does this pretty well.

30
00:01:26,125 --> 00:01:29,440
 First, it shows us the constraints under which we're operating right there

31
00:01:29,440 --> 00:01:33,320
 visibly on the screen so we're not left guessing as to what we're supposed to be doing.

32
00:01:33,320 --> 00:01:35,000
 Then as we start to interact,

33
00:01:35,000 --> 00:01:37,420
 it tells us if we're violating any of those constraints.

34
00:01:37,420 --> 00:01:42,400
 So, if I were to just try to make my password the incredibly common 1234,

35
00:01:42,400 --> 00:01:45,010
 it immediately tells me that my password isn't long

36
00:01:45,010 --> 00:01:48,020
 enough and it doesn't represent enough character classes.

37
00:01:48,020 --> 00:01:51,730
 Now, obviously, it can't prevent me from entering 1234 in the first place,

38
00:01:51,730 --> 00:01:55,235
 since maybe that's along the way to a longer more valid password.

39
00:01:55,235 --> 00:01:58,900
 But it's visualizing those constraints so that instead of submitting and

40
00:01:58,900 --> 00:02:00,610
 getting frustrated when it didn't tell me I

41
00:02:00,610 --> 00:02:02,680
 was doing it wrong until I'd actually done it,

42
00:02:02,680 --> 00:02:06,275
 it actually tells me right in the context of doing it I'm not on the right track.

43
00:02:06,275 --> 00:02:08,030
 This is kind of a soft constraint.

44
00:02:08,030 --> 00:02:09,870
 It doesn't prevent me from doing something,

45
00:02:09,870 --> 00:02:12,570
 but it tells me while I'm doing it that I'm doing it wrong.

46
00:02:12,570 --> 00:02:15,650
 A harder constraint goes along with that last bullet: can

47
00:02:15,650 --> 00:02:18,740
 only contain characters printed on the computer's keyboard.

48
00:02:18,740 --> 00:02:22,640
 Right now, I'm trying to paste in a character that isn't on the computer keyboard,

49
00:02:22,640 --> 00:02:24,500
 and it's just not showing it all together.

50
00:02:24,500 --> 00:02:27,710
 It's a hard constraint against the inputting characters that aren't allowed.

51
00:02:27,710 --> 00:02:32,035
 So, it's preventing me from putting an invalid input in the first place.

52
00:02:32,035 --> 00:02:33,670
 So, in their simplest form,

53
00:02:33,670 --> 00:02:35,900
 constraints can be described as preventing the user

54
00:02:35,900 --> 00:02:35,900
 from putting an input that wasn't going to work anyway.

